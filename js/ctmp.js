const Uint8Array_=Uint8Array,createUint8ArrayByLen=e=>new Uint8Array_(e),createUint8ArrayByBuffer=(e,r,t)=>new Uint8Array_(e,r,t),createUint8ArrayByArrayBuffer=e=>new Uint8Array_(e),createPromise=e=>new Promise(e),pall=e=>Promise.all(e),presolve=e=>Promise.resolve(e),error=e=>new Error(e),max=(e,r)=>e>r?e:r,bits7=127;class Encoder{constructor(){this.cpos=0,this.cbuf=createUint8ArrayByLen(1e3),this.bufs=[]}}const createEncoder=()=>new Encoder,length=e=>{let r=0;for(let t=0;t<e.bufs.length;t++)r+=e.bufs[t].length;return r+=e.cpos},toBuffer=e=>{const r=createUint8ArrayByLen(length(e));let t=0;for(let o=0;o<e.bufs.length;o++){let n=e.bufs[o];r.set(n,t),t+=n.length}return r.set(createUint8ArrayByBuffer(e.cbuf.buffer,0,e.cpos),t),r.buffer},write=(e,r)=>{e.cpos===e.cbuf.length&&(e.bufs.push(e.cbuf),e.cbuf=createUint8ArrayByLen(2*e.cbuf.length),e.cpos=0),e.cbuf[e.cpos++]=r},writeVarUint=(e,r)=>{for(;r>=128;)write(e,128|127&r),r>>>=7;write(e,127&r)},writeVarString=(e,r)=>{const t=unescape(encodeURIComponent(r)),o=t.length;writeVarUint(e,o);for(let r=0;r<o;r++)write(e,t.codePointAt(r))},writeArrayBuffer=(e,r)=>{const t=e.cbuf.length;e.bufs.push(createUint8ArrayByBuffer(e.cbuf.buffer,0,e.cpos)),e.bufs.push(createUint8ArrayByArrayBuffer(r)),e.cbuf=createUint8ArrayByLen(t),e.cpos=0};class Decoder{constructor(e){this.arr=new Uint8Array(e),this.pos=0}}const createDecoder=e=>new Decoder(e),readArrayBuffer=(e,r)=>{const t=createUint8ArrayByLen(r),o=createUint8ArrayByBuffer(e.arr.buffer,e.pos,r);return t.set(o),e.pos+=r,t.buffer},readTail=e=>readArrayBuffer(e,e.arr.length-e.pos),readVarUint=e=>{let r=0,t=0;for(;;){let o=e.arr[e.pos++];if(r|=(127&o)<<t,t+=7,o<128)return r>>>0;if(t>35)throw new Error("Integer out of range!")}},readVarString=e=>{let r=readVarUint(e),t="";for(;r>0;){const o=r<1e4?r:1e4,n=new Array(o);for(let r=0;r<o;r++)n[r]=e.arr[e.pos++];t+=String.fromCodePoint.apply(null,n),r-=o}return decodeURIComponent(escape(t))},rtop=e=>createPromise((r,t)=>{e.onerror=(e=>t(new Error(e.target.error))),e.onblocked=(()=>location.reload()),e.onsuccess=(e=>r(e.target.result))}),openDB=(e,r)=>createPromise((t,o)=>{let n=indexedDB.open(e);n.onupgradeneeded=(e=>r(e.target.result)),n.onerror=(e=>o(new Error(e.target.error))),n.onblocked=(()=>location.reload()),n.onsuccess=(e=>{const r=e.target.result;r.onversionchange=(()=>{r.close()}),addEventListener("unload",()=>r.close()),t(r)})}),deleteDB=e=>rtop(indexedDB.deleteDatabase(e)),createStores=(e,r)=>r.forEach(r=>e.createObjectStore.apply(e,r)),get=(e,r)=>rtop(e.get(r)),del=(e,r)=>rtop(e.delete(r)),put=(e,r,t)=>rtop(e.put(r,t)),addAutoKey=(e,r)=>rtop(e.add(r)),getAll=(e,r)=>rtop(e.getAll(r)),getAllKeys=(e,r)=>rtop(e.getAllKeys(r)),iterate=(e,r,t)=>createPromise((o,n)=>{const a=e.openCursor(r);a.onerror=n,a.onsuccess=(e=>{const r=e.target.result;if(null===r)return o();t(r.value,r.key),r.continue()})}),getStore=(e,r)=>e.objectStore(r),createIDBKeyRangeBound=(e,r,t,o)=>IDBKeyRange.bound(e,r,t,o),createIDBKeyRangeLowerBound=(e,r)=>IDBKeyRange.lowerBound(e,r),getStoreCU=e=>getStore(e,"client-unconfirmed"),getStoreHU=e=>getStore(e,"host-unconfirmed"),getStoreCo=e=>getStore(e,"confirmed"),encodeHUKey=(e,r)=>[e,r],decodeHUKey=e=>({room:e[0],offset:e[1]}),openDB$1=()=>openDB("ydb-client",e=>createStores(e,[["client-unconfirmed",{autoIncrement:!0}],["host-unconfirmed"],["confirmed"]])),deleteDB$1=e=>deleteDB(e),createTransaction=e=>e.transaction(["client-unconfirmed","host-unconfirmed","confirmed"],"readwrite"),writeClientUnconfirmed=(e,r,t)=>{const o=createEncoder();return writeVarString(o,r),writeArrayBuffer(o,t),addAutoKey(getStoreCU(e),toBuffer(o))},writeHostUnconfirmedByClient=(e,r,t)=>get(getStoreCU(e),r).then(o=>{const n=createDecoder(o),a=readVarString(n),c=readTail(n);return writeHostUnconfirmed(e,a,t,c).then(()=>del(getStoreCU(e),r))}),writeHostUnconfirmed=(e,r,t,o)=>put(getStoreHU(e),o,encodeHUKey(r,t)),writeConfirmedByHost=(e,r,t)=>{const o=getStoreCo(e),n="data:"+r,a="meta:"+r;return pall([get(o,n),get(o,a)]).then(c=>{const i=c[0],s=c[1],f=decodeMetaValue(s).roomsid,u=createEncoder();writeArrayBuffer(u,i);const d=getStoreHU(e),l=createIDBKeyRangeBound(encodeHUKey(r,0),encodeHUKey(r,t),!1,!1);return iterate(d,l,(e,o)=>{const n=decodeHUKey(o);n.room===r&&n.offset<=t&&writeArrayBuffer(u,e)}).then(()=>pall([put(o,encodeMetaValue(f,t),a),put(o,toBuffer(u),n),del(d,l)]))})},getRoomMetas=e=>{const r=getStoreHU(e),t=[];return iterate(getStoreCo(e),createIDBKeyRangeLowerBound("meta:",!1),(e,o)=>getAllKeys(r,createIDBKeyRangeBound(encodeHUKey(o.slice(5),0),encodeHUKey(o.slice(5),2**32),!1,!1)).then(r=>{const{roomsid:n,offset:a}=decodeMetaValue(e);t.push({room:o.slice(5),roomsid:n,offset:r.reduce((e,r)=>max(decodeHUKey(r).offset,e),a)})})).then(()=>presolve(t))},getRoomData=(e,r)=>pall([get(getStoreCo(e),"data:"+r),getAll(getStoreHU(e),createIDBKeyRangeBound(encodeHUKey(r,0),encodeHUKey(r,2**32),!1,!1))]).then(([e,r])=>{const t=createEncoder();return writeArrayBuffer(t,e),r.map(e=>writeArrayBuffer(t,e)),toBuffer(t)}),decodeMetaValue=e=>{const r=createDecoder(e);return{roomsid:readVarUint(r),offset:readVarUint(r)}},encodeMetaValue=(e,r)=>{const t=createEncoder();return writeVarUint(t,e),writeVarUint(t,r),toBuffer(t)},writeInitialRoomData=(e,r,t,o,n)=>pall([put(getStoreCo(e),encodeMetaValue(t,o),"meta:"+r),put(getStoreCo(e),n,"data:"+r)]),run=(e,r)=>{console.info(e);const t=new Date;r(e),console.info(`Success: ${e} in ${(new Date).getTime()-t.getTime()}ms`)},compareArrays=(e,r)=>{if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==r[t])return!1;return!0};deleteDB$1().then(()=>openDB$1()).then(e=>{run("update lifetime 1",async r=>{const t=new Uint8Array([1,2,3]).buffer,o=createTransaction(e);writeInitialRoomData(o,r,42,1,new Uint8Array([0]).buffer);const n=await writeClientUnconfirmed(o,r,t);await writeHostUnconfirmedByClient(o,n,0),await writeConfirmedByHost(o,r,4);const a=(await getRoomMetas(o)).find(e=>e.room===r);if(null==a||4!==a.offset||42!==a.roomsid)throw error();const c=await getRoomData(o,r);if(!compareArrays(new Uint8Array(c),new Uint8Array([0,1,2,3])))throw error()})});
