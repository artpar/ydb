
# Ydb
> A distributed database for Yjs documents. 

Ydb is the ideal endpoint for shared editing apps based on Yjs. It implements a unique way to persist shared documents and implements a new syncing mechanism that allows users to sync thousands of documents in a single call. While Ydb is an endpoint for Yjs, Ydb itself does not understand the content of a shared document.

The goal of Yjs was always to bring a reliable approach to edit notes in realtime and while offline. Notes are stored in indexeddb to allow faster access and sync to other clients when a connection is available. But syncing thousands of documents is not feasible in Yjs sync, because it requires to load the shared document to memory.

Past implements of Yjs endpoints were based on key-value storages like LevelDB. But storage for shared documents based on Yjs is very unique for several reasons:
1. A Yjs document is an append-only log of operations. It does not require indexing or querying that is an integral part of common databases. In Ydb, a client fetches changes based on the local byte-size of the shared document. If the size doesn't match, Ydb replies with the content that the client does not know about. More about offset-based syncing and shrinking of shared documents in [#Syncing](#Syncing)
2. Shared documents are edited over a short period of time. There is a good chance that the shared document is never edited after that. When a document is not accessed over a longer period of time, Ydb can store the document in Object Storage instead. Depending on the provider you use, Object Storage may be 10x times cheaper than storage on a local HDD.
3. While users are active Ydb also shares presence information like names of active users on a document/collection, cursor location, and availability status. Presence information is not persisted but shared among all active users. 

In terms of the CAP theorem, Ydb is an available (A), partition-tolerant (P) distributed database. This means that the communication between the servers may fail, but clients can always sync their documents to the server. 
It has been shown that it is impossible to implement a distributed database, that also provides consistency (C) - clients will always receive the latest content. But since operations in Yjs are commutative, Ydb also ensures **eventual** consistency (C) among the Ydb instances and clients.  

## Concepts

*Document:* A shared document that is uniquely defined by its **UUID**. A document must be part of a collection. Internally it is handled as an append-only log of changes. A document may be shrunk by doing garbage collection on the shared document with Yjs. 

*Collection:* A collection is a set of documents. A collection must be associated with a user account.

*(document) Host:* Each document is assigned to a Ydb instance (see [#Data distribution and hashing](#Data distribution and hashing)). The Ydb instance that owns a document is the document host. It will handle the distribution of updates and persistence information. This is not necessarily the instance we connect to. Hence the distinction.

### Syncing

##### Offset based syncing
In Ydb, a document is stored as a simple append-only file on the hard drive. The `document` instance also holds the amount of information ever created on the document as **offset** and a unique identifier **documentSessionID** that is randomly generated by a Ydb instance. The **documentSessionID** guarantees that client and host talk about the same document. In case a Ydb instance closes unexpectedly, new Ydb instances will be assigned as hosts of the documents, and the **documentSessionID** changes. Since the session id changes, clients are forced to resync the document by either doing a [Yjs based sync](#Yjs based sync) or a [Brute-force sync](#Brute-force sync).

TODO: sync protocol here

##### Yjs based sync
Yjs based sync is a minimal sync in terms of data exchanged. But it requires both client and server to load the document to memory.

1. *Sync Step 1:* Client computes the **state vector** of the local document and sends it to the server. This is basically an array of integer pairs: `[ [userid1, amountOfContentCreatedByUserId1], ..]`
2. *Sync step 2:* Server loads document to memory. Then it computes all missing operations based on **sync step 1** and sends it to the client. It also computes a state vector and sends it to the client. Then the document is removed from memory.
3 *Update server:* The client computers all missing changes based on the state vector provided by the server and sends it to the server.
4. The server appends missing operations from the client to the local document file. Client and server are in sync.

Ydb does not understand the Yjs model at the moment. Therefore we use [Brute-force sync](#Brute-force sync) as it is easier to implement and more reliable for now. Ydb will support Yjs based sync in the future.

##### Brute-force sync

Simple. If the `documentSessionID` does not match, the client enforces a **brute-force sync**. Both client and server exchange the local version of the document and append it to the local document structure. 

The client will be able to recognize duplicate operations. But the size of the document stored on the server will essentially double until it is shrunk.

Keep in mind that a brute-force sync is only enforced when a Ydb instance dies unexpectedly.  It has the advantage that no data is loaded to memory, and it is very easy to implement. But the disadvantage is that potentially huge amount of content needs to be exchanged between client and server until they are synced. Brute-force sync will ensure eventual consistency until we implemented a Go version of the Yjs sync protocol.

### Data distribution and hashing


https://docs.datastax.com/en/archived/cassandra/2.1/cassandra/architecture/architectureDataDistributeAbout_c.html

https://docs.datastax.com/en/archived/cassandra/2.1/cassandra/architecture/architectureDataDistributeHashing_c.html


### TODO
* rewrite writeVaruint to only accept 32 uints as js does only support 32 bit encoding